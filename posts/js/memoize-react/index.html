<!DOCTYPE html>
<html class="no-js" lang="en-us">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>记忆化技术介绍 - Matt&#39;s Home</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<meta property="og:title" content="记忆化技术介绍" />
<meta property="og:description" content="动机 在开发 React 项目中，有一种场景很常见：从服务器中请求了一个数据结构，这个结构非常复杂，甚至还有一些垃" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/posts/js/memoize-react/" />
<meta property="article:published_time" content="2019-03-18T12:22:37+08:00" />
<meta property="article:modified_time" content="2019-03-18T12:22:37+08:00" />

	<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="记忆化技术介绍"/>
<meta name="twitter:description" content="动机 在开发 React 项目中，有一种场景很常见：从服务器中请求了一个数据结构，这个结构非常复杂，甚至还有一些垃"/>

	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">
	<link rel="stylesheet" href="/css/style.css">
	<link rel="stylesheet" href="/css/custom.css">
	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container">
		<div class="logo">
			<a class="logo__link" href="/" title="Matt&#39;s Home" rel="home">
				<div class="logo__title">Matt&#39;s Home</div>
				<div class="logo__tagline">无产阶级工人/Coder 🔨</div>
			</a>
		</div>
		
<nav class="menu">
	<button class="menu__btn" aria-haspopup="true" aria-expanded="false" tabindex="0">
		<span class="menu__btn-title" tabindex="-1">Menu</span>
	</button>
	<ul class="menu__list">
		<li class="menu__item">
			<a class="menu__link" href="/about/aboutme/">
				
				<span class="menu__text">About Me</span>
				
			</a>
		</li>
		<li class="menu__item">
			<a class="menu__link" href="/about/aboutsite/">
				
				<span class="menu__text">About This Site</span>
				
			</a>
		</li>
		<li class="menu__item">
			<a class="menu__link" href="https://github.com/yuqingc/yuqingc.github.io/issues">
				
				<span class="menu__text">Feedback</span>
				
			</a>
		</li>
		<li class="menu__item">
			<a class="menu__link" href="https://github.com/yuqingc">
				
				<span class="menu__text">GitHub</span>
				
			</a>
		</li>
		<li class="menu__item">
			<a class="menu__link" href="/categories/music/">
				
				<span class="menu__text">Music</span>
				
			</a>
		</li>
	</ul>
</nav>

	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">记忆化技术介绍</h1>
			<p class="post__lead">使用闭包提升你的 React 性能</p>
			<div class="post__meta meta">
<div class="meta__item-datetime meta__item">
	<svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg>
	<time class="meta__text" datetime="2019-03-18T12:22:37">March 18, 2019</time>
</div>

<div class="meta__item-categories meta__item">
	<svg class="meta__icon icon icon-category" width="16" height="16" viewBox="0 0 16 16"><path d="m7 2l1 2h8v11h-16v-13z"/></svg>
	<span class="meta__text"><a class="meta__link" href="/categories/blogs/" rel="category">blogs</a>
	</span>
</div></div>
		</header>
		<figure class="post__thumbnail">
			<img src="/images/react-logo.jpg" alt="记忆化技术介绍">
		</figure>
<div class="post__toc toc">
	<div class="toc__title">Page content</div>
	<div class="toc__menu">
		<nav id="TableOfContents">
  <ul>
    <li><a href="#动机">动机</a></li>
    <li><a href="#记忆化技术">记忆化技术</a></li>
    <li><a href="#react-中使用-memoize-one">React 中使用 memoize-one</a>
      <ul>
        <li><a href="#1-安装">1. 安装</a></li>
        <li><a href="#2-api-简介以及用例">2. API 简介以及用例</a></li>
        <li><a href="#3-在-react-中使用-memoize-one">3. 在 React 中使用 memoize-one</a></li>
      </ul>
    </li>
    <li><a href="#使用闭包来实现记忆化技术">使用闭包来实现记忆化技术</a></li>
    <li><a href="#补充react-hook-中的记忆化技术提高你的组件性能-2019-年-3-月-更新">补充：React Hook 中的记忆化技术提高你的组件性能 (2019 年 3 月 更新)</a></li>
    <li><a href="#个人看法">个人看法</a></li>
    <li><a href="#参考资料">参考资料</a></li>
  </ul>
</nav>
	</div>
</div>
<div class="content post__content clearfix">
			<h2 id="动机">动机</h2>
<p>在开发 React 项目中，有一种场景很常见：从服务器中请求了一个数据结构，这个结构非常复杂，甚至还有一些垃圾字段。这个数据结构一般通过 React 组件的 props 传入组件。而我们在 render 的时候需要对这个很复杂的数据结构要做处理，比如过滤一些无用的信息，或者重新组合这个数据结构以便更方便的 render。</p>
<p>来看一下这个例子：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-jsx" data-lang="jsx"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Example</span> <span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">PureComponent</span> {
  <span style="color:#75715e">// 当前的过滤文本:
</span><span style="color:#75715e"></span>  <span style="color:#a6e22e">state</span> <span style="color:#f92672">=</span> {
    <span style="color:#a6e22e">filterText</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;&#34;</span>
  };

  <span style="color:#a6e22e">handleChange</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">event</span> =&gt; {
    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">setState</span>({ <span style="color:#a6e22e">filterText</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">event</span>.<span style="color:#a6e22e">target</span>.<span style="color:#a6e22e">value</span> });
  };

  <span style="color:#a6e22e">render</span>() {
    <span style="color:#75715e">// 在 PureComponent 中，render 方发只有在 state.filterText 和 props.list
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 变化的时候才会重新调用
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">filteredList</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">props</span>.<span style="color:#a6e22e">list</span>.<span style="color:#a6e22e">filter</span>(
      <span style="color:#a6e22e">item</span> =&gt; <span style="color:#a6e22e">item</span>.<span style="color:#a6e22e">text</span>.<span style="color:#a6e22e">includes</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">state</span>.<span style="color:#a6e22e">filterText</span>)
    )

    <span style="color:#66d9ef">return</span> (
      &lt;<span style="color:#f92672">Fragment</span>&gt;
        &lt;<span style="color:#f92672">input</span> <span style="color:#a6e22e">onChange</span><span style="color:#f92672">=</span>{<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">handleChange</span>} <span style="color:#a6e22e">value</span><span style="color:#f92672">=</span>{<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">state</span>.<span style="color:#a6e22e">filterText</span>} /&gt;
        &lt;<span style="color:#f92672">ul</span>&gt;{<span style="color:#a6e22e">filteredList</span>.<span style="color:#a6e22e">map</span>(<span style="color:#a6e22e">item</span> =&gt; &lt;<span style="color:#f92672">li</span> <span style="color:#a6e22e">key</span><span style="color:#f92672">=</span>{<span style="color:#a6e22e">item</span>.<span style="color:#a6e22e">id</span>}&gt;{<span style="color:#a6e22e">item</span>.<span style="color:#a6e22e">text</span>}&lt;/<span style="color:#f92672">li</span>&gt;)}&lt;/<span style="color:#f92672">ul</span>&gt;
      &lt;/<span style="color:#f92672">Fragment</span>&gt;
    );
  }
}
</code></pre></div><p>在上面这个例子中，<code>filter</code> 这一段代码的逻辑其实就是我们所说的，对 从服务器拿来的数据结构 进行处理的过程。每一次调用 <code>render</code> 方法都会调用 <code>filter</code> 这段逻辑。我们在一个组件中更新其实是比较频繁的，而 <code>filter</code> 的逻辑其实也相当占用CPU资源以及时间。如果每次更新调用 <code>render</code> 方法都要走一次这一段 <code>filter</code> 的逻辑，其实是非常消耗时间的。这对 App 的性能也会造成影响。</p>
<p>而在实际的开发中，数据结构往往更加复杂，有时候甚至会有多次的循环。有时候组件的更新并不是因为从服务器拿来的这一段数据结构发生变化造成的（组件中的其他部分更新造成的），但是这一段很重的逻辑因为是写在 <code>render</code> 中的，所以不可避免的在每次 <code>render</code> 会调用一次。如果这段逻辑在两次调用的时候，输入参数是一样的，那么输出结果必然一样，所以再次计算是一种十分浪费资源的行为。</p>
<p>那么有没有一种方法可以避免这种行为呢？确实是有的，下面我们介绍一种名为 <em>memoization</em> 的技术，中文翻译叫 “记忆化技术”</p>
<h2 id="记忆化技术">记忆化技术</h2>
<p>记忆化，顾名思义，就是把函数的调用结果记下来，或者缓存下来。如果下次调用这个函数的时候，输入的参数和上一次的完全一致，那么我们就不需要再次进行计算，而是把上一此的结果直接返回。</p>
<p>看一下维基百科对记忆化的定义：</p>
<blockquote>
<p>在计算机科学中，记忆化（英語：memoization 而非 memorization）是一种提高程序运行速度的优化技术。通过储存大计算量函数的返回值，当这个结果再次被需要时将其从缓存提取，而不用再次计算来节省计算时间。记忆化是一种典型的时间存储平衡方案。</p>
</blockquote>
<h2 id="react-中使用-memoize-one">React 中使用 memoize-one</h2>
<p>根据 &ldquo;memoize-one&rdquo; 的名字可以知道，这个库缓存了一个结果 <em>ONE</em> ， 而不是 <em>TWO</em> 或者其他数字。缓存一次而不是多次，可以节约内存。虽然只有一次，但不失为一个很好的折中方案。</p>
<p>在上一节的 React 的场景中，如果把之前计算的结果缓存起来，这样每次 <code>render</code> 的时候，如果从服务器拿到的数据结构和上一次 <code>render</code> 的时候一样，就可以非常快的把结果渲染出来。这样本来需要 O(n) ，O(n2) 甚至更高复杂度的算法，我们瞬间可以以 O(1) 的效率把结果直接从缓存中读取出来。</p>
<p>说了这么多，我们来看一下这个 <em>memoize-one</em> 到底是怎么用的呢？</p>
<h3 id="1-安装">1. 安装</h3>
<pre><code>$ npm install memoize-one
</code></pre><h3 id="2-api-简介以及用例">2. API 简介以及用例</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">import</span> <span style="color:#a6e22e">memoizeOne</span> <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#39;memoize-one&#39;</span>;
 
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">add</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span>) =&gt; <span style="color:#a6e22e">a</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">b</span>;
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">memoizedAdd</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">memoizeOne</span>(<span style="color:#a6e22e">add</span>);
 
<span style="color:#a6e22e">memoizedAdd</span>(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>); <span style="color:#75715e">// 3
</span><span style="color:#75715e"></span> 
<span style="color:#a6e22e">memoizedAdd</span>(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>); <span style="color:#75715e">// 3
</span><span style="color:#75715e">// Add 函数并没有执行: 前一次执行的结果被返回
</span><span style="color:#75715e"></span> 
<span style="color:#a6e22e">memoizedAdd</span>(<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>); <span style="color:#75715e">// 5
</span><span style="color:#75715e">// Add 函数再次被调用以获得新的结果
</span><span style="color:#75715e"></span> 
<span style="color:#a6e22e">memoizedAdd</span>(<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>); <span style="color:#75715e">// 5
</span><span style="color:#75715e">// Add 函数并没有执行: 前一次执行的结果被返回
</span><span style="color:#75715e"></span> 
<span style="color:#a6e22e">memoizedAdd</span>(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>); <span style="color:#75715e">// 3
</span><span style="color:#75715e">// Add 函数再次被调用以获得新的结果
</span><span style="color:#75715e">// 虽然之前调用过
</span><span style="color:#75715e">// 但是不是上一次调用的，所以结果丢失了
</span></code></pre></div><h3 id="3-在-react-中使用-memoize-one">3. 在 React 中使用 memoize-one</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-jsx" data-lang="jsx"><span style="color:#66d9ef">import</span> <span style="color:#a6e22e">memoize</span> <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#34;memoize-one&#34;</span>;

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Example</span> <span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">Component</span> {
  <span style="color:#75715e">// 当前的过滤文本:
</span><span style="color:#75715e"></span>  <span style="color:#a6e22e">state</span> <span style="color:#f92672">=</span> { <span style="color:#a6e22e">filterText</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;&#34;</span> };

  <span style="color:#75715e">// 只有在 list 和 filterText 改变的时候才会重新执行 filter 函数
</span><span style="color:#75715e"></span>  <span style="color:#a6e22e">filter</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">memoize</span>(
    (<span style="color:#a6e22e">list</span>, <span style="color:#a6e22e">filterText</span>) =&gt; <span style="color:#a6e22e">list</span>.<span style="color:#a6e22e">filter</span>(<span style="color:#a6e22e">item</span> =&gt; <span style="color:#a6e22e">item</span>.<span style="color:#a6e22e">text</span>.<span style="color:#a6e22e">includes</span>(<span style="color:#a6e22e">filterText</span>))
  );

  <span style="color:#a6e22e">handleChange</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">event</span> =&gt; {
    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">setState</span>({ <span style="color:#a6e22e">filterText</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">event</span>.<span style="color:#a6e22e">target</span>.<span style="color:#a6e22e">value</span> });
  };

  <span style="color:#a6e22e">render</span>() {
    <span style="color:#75715e">// 计算最新的过滤值. 如果参数没有发生改变
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 之前的一次 render 之后, `memoize-one` 会再次利用上一次的返回结果.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">filteredList</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">filter</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">props</span>.<span style="color:#a6e22e">list</span>, <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">state</span>.<span style="color:#a6e22e">filterText</span>);

    <span style="color:#66d9ef">return</span> (
      &lt;<span style="color:#f92672">Fragment</span>&gt;
        &lt;<span style="color:#f92672">input</span> <span style="color:#a6e22e">onChange</span><span style="color:#f92672">=</span>{<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">handleChange</span>} <span style="color:#a6e22e">value</span><span style="color:#f92672">=</span>{<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">state</span>.<span style="color:#a6e22e">filterText</span>} /&gt;
        &lt;<span style="color:#f92672">ul</span>&gt;{<span style="color:#a6e22e">filteredList</span>.<span style="color:#a6e22e">map</span>(<span style="color:#a6e22e">item</span> =&gt; &lt;<span style="color:#f92672">li</span> <span style="color:#a6e22e">key</span><span style="color:#f92672">=</span>{<span style="color:#a6e22e">item</span>.<span style="color:#a6e22e">id</span>}&gt;{<span style="color:#a6e22e">item</span>.<span style="color:#a6e22e">text</span>}&lt;/<span style="color:#f92672">li</span>&gt;)}&lt;/<span style="color:#f92672">ul</span>&gt;
      &lt;/<span style="color:#f92672">Fragment</span>&gt;
    );
  }
}
</code></pre></div><p>这样，我们就在 React 中实现了记忆化，性能也会得到提升。因为这样可以避免 render 的时候，浪费性地调用复杂的数据处理函数。</p>
<p>那么在 JavaScript 中，记忆化函数 <em>memoize-one</em> 是如何实现的呢？</p>
<h2 id="使用闭包来实现记忆化技术">使用闭包来实现记忆化技术</h2>
<p>在前面的代码中，我们并没有看到上一次返回的结果被显式的存在一个缓存变量中。那么究竟是如何实现缓存的呢？其实很简单，缓存技术使用了 JavaScript 中的 <em>闭包</em> 。</p>
<p>本文假定你熟悉 JavaScript 中闭包的概念，如果你不熟悉闭包，可以参考<a href="https://github.com/getify/You-Dont-Know-JS/blob/1ed-zh-CN/scope%20&amp;%20closures/README.md#you-dont-know-js-scope--closures">你不知道的JavaScript——作用域与闭包</a></p>
<p>momoize-one 的源码可以在 <a href="https://github.com/alexreardon/memoize-one/blob/master/src/index.js">GitHub</a> 中查看，源码只有三十几行，非常简单，也很好理解。下面我把源码更简化一下，来介绍这个库实现的原理。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">memoize</span> (<span style="color:#a6e22e">resultFn</span>) {
  <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">lastArgs</span> <span style="color:#f92672">=</span> []; <span style="color:#75715e">// 用来存放上一次调用的参数
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">lastResult</span>; <span style="color:#75715e">// 用来缓存上一次的结果
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">calledOnce</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">boolean</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>; <span style="color:#75715e">// 是否调用过，刚开始的时候是false
</span><span style="color:#75715e"></span>
  <span style="color:#75715e">// 判断两次调用的时候的参数是否相等
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 这里的 `isEqual` 是一个抽象函数，用来判断两个值是否相等
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">isNewArgEqualToLast</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">newArg</span>, <span style="color:#a6e22e">index</span>) =&gt; <span style="color:#a6e22e">isEqual</span>(<span style="color:#a6e22e">newArg</span>, <span style="color:#a6e22e">lastArgs</span>[<span style="color:#a6e22e">index</span>]);

  <span style="color:#75715e">// 如果上一次的参数和这一次一样，直接返回上一次的结果
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">result</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span> (...<span style="color:#a6e22e">newArgs</span>) {
    <span style="color:#66d9ef">if</span> (
      <span style="color:#a6e22e">calledOnce</span> <span style="color:#f92672">&amp;&amp;</span>
      <span style="color:#a6e22e">newArgs</span>.<span style="color:#a6e22e">length</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">lastArgs</span>.<span style="color:#a6e22e">length</span> <span style="color:#f92672">&amp;&amp;</span>
      <span style="color:#a6e22e">newArgs</span>.<span style="color:#a6e22e">every</span>(<span style="color:#a6e22e">isNewArgEqualToLast</span>)
    ) {
      <span style="color:#75715e">// 如果和上次的参数一致， 直接返回缓存的值
</span><span style="color:#75715e"></span>      <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">lastResult</span>;
    }

    <span style="color:#75715e">// 如果和上一次的参数不一致，我们需要再次调用原来的函数
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">calledOnce</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>; <span style="color:#75715e">// 标记为调用过
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">lastArgs</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">newArgs</span>; <span style="color:#75715e">// 重新缓存参数
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">lastResult</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">resultFn</span>.<span style="color:#a6e22e">apply</span>(<span style="color:#66d9ef">this</span>, <span style="color:#a6e22e">newArgs</span>); <span style="color:#75715e">//重新缓存返回值
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">lastResult</span>;
  }

  <span style="color:#75715e">// 返回闭包函数
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">result</span>;
}
</code></pre></div><p>原理非常简单，可以通过我的注释来理解。</p>
<p>注意，我的代码中有一个 <code>isEqual</code> 的抽象函数，用来判断两次的参数是否一致。因为对相等的理解，不同场景不一样，而且参数有时候是复杂的对象，所以我们不能仅仅通过比较操作符 <code>==</code> 或者 <code>===</code> 来判断。<em>memoize-one</em> 允许用户自定义传入判断是否相等的函数，比如我们可以使用 <em>lodash</em> 的 <code>isEqual</code> 来判断两次参数是否相等。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">import</span> <span style="color:#a6e22e">memoizeOne</span> <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#39;memoize-one&#39;</span>;
<span style="color:#66d9ef">import</span> <span style="color:#a6e22e">deepEqual</span> <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#39;lodash.isEqual&#39;</span>;
 
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">identity</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">x</span> =&gt; <span style="color:#a6e22e">x</span>;
 
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">defaultMemoization</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">memoizeOne</span>(<span style="color:#a6e22e">identity</span>);
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">customMemoization</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">memoizeOne</span>(<span style="color:#a6e22e">identity</span>, <span style="color:#a6e22e">deepEqual</span>);
 
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">result1</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">defaultMemoization</span>({<span style="color:#a6e22e">foo</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;bar&#39;</span>});
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">result2</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">defaultMemoization</span>({<span style="color:#a6e22e">foo</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;bar&#39;</span>});
 
<span style="color:#a6e22e">result1</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">result2</span> <span style="color:#75715e">// false - 索引不同
</span><span style="color:#75715e"></span> 
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">result3</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">customMemoization</span>({<span style="color:#a6e22e">foo</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;bar&#39;</span>});
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">result4</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">customMemoization</span>({<span style="color:#a6e22e">foo</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;bar&#39;</span>});
 
<span style="color:#a6e22e">result3</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">result4</span> <span style="color:#75715e">// true - 参数通过 lodash 的 isEqual 判断是相等的
</span></code></pre></div><h2 id="补充react-hook-中的记忆化技术提高你的组件性能-2019-年-3-月-更新">补充：React Hook 中的记忆化技术提高你的组件性能 (2019 年 3 月 更新)</h2>
<p>React 16.8 带来了全新的 Hook。Hook 为我们提供了原生的记忆化 API，我们可以使用 <a href="https://reactjs.org/docs/hooks-reference.html#usememo">useMemo</a> 来实现上文所说的记忆化技术。具体用法请直接参考 API 文档。也可以阅读 Dan 的这篇文章：<a href="https://overreacted.io/writing-resilient-components/">Writing Resilient Components</a></p>
<h2 id="个人看法">个人看法</h2>
<p><em>闭包</em> 在函数式编程里面的确是不可或缺的一部分，把闭包函数当作值来进行传递可以让程序更加灵活。但是以上这种把函数局部变量保留的方式，我 <strong>不认为</strong> 是一种很好的编程范式，因为 Runtime 的 GC 在函数应该销毁时，不去回收这一部分的内存，很容易造成内存泄漏。</p>
<p>在 Golang 中，也有类似的闭包概念，Golang 中允许在函数中返回局部变量的指针，GC 在函数返回之后不会回收被这个指针指向的内存，这往往被称作“变量逃逸”。而在 Rust 语言中，如果在在函数中返回一个局部变量的引用，编译器会直接报错。</p>
<p>尽管灵活使用闭包可以使得代码更加简单，也会给初学者一种“高大上”的感觉，但是其实不用闭包也可以达到类似的效果（比如使用 class，让记忆化技术中部的缓存变量作为 class 的一个私有属性即可）。</p>
<p>在实际工程中应该尽量减少使用 <em>局部变量逃逸</em> 的闭包函数，这样不但可以增加程序的可读性，而且可以更好的追踪 bug 的产生，最重要的是，使你的代码更安全。</p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li>
<p><a href="https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#what-about-memoization">You Probably Don&rsquo;t Need Derived State</a></p>
</li>
<li>
<p><a href="https://www.npmjs.com/package/memoize-one">memoize-one</a></p>
</li>
</ul>
<hr>
<p><em>Authored by <a target="_blank" href="https://github.com/yuqingc">@yuqingc</a> 转载请注明出处</em></p>

		</div>
		<footer class="post__footer">
			
<div class="post__tags tags clearfix">
	<svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5 0 11V3C0 1.5.8.8.8.8S1.5 0 3 0h8c1.5 0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 1 0 0-6 3 3 0 0 0 0 6z"/></svg>
	<ul class="tags__list">
		<li class="tags__item"><a class="tags__link btn" href="/tags/javascript/" rel="tag">javascript</a></li>
		<li class="tags__item"><a class="tags__link btn" href="/tags/react/" rel="tag">react</a></li>
	</ul>
</div>
		</footer>
	</article>
</main>

<div class="authorbox clearfix">
	<figure class="authorbox__avatar">
		<img alt="Matt avatar" src="/images/avatar.jpg" class="avatar" height="90" width="90">
	</figure>
	<div class="authorbox__header">
		<span class="authorbox__name">About Matt</span>
	</div>
	<div class="authorbox__description">
		当我和世界初相见 当我曾经是少年
	</div>
</div>

<nav class="post-nav flex">
	<div class="post-nav__item post-nav__item--next">
		<a class="post-nav__link" href="/posts/js/you-might-not-know-this/" rel="next"><span class="post-nav__caption">Next&thinsp;»</span><p class="post-nav__post-title">You Might Not Know &#34;this&#34;</p></a>
	</div>
</nav>


			</div>
			<aside class="sidebar">
<div class="widget-recent widget">
	<h4 class="widget__title">Recent Posts</h4>
	<div class="widget__content">
		<ul class="widget__list">
			<li class="widget__item"><a class="widget__link" href="/posts/go/go-module-tutorial/">使用 Go Modules</a></li>
			<li class="widget__item"><a class="widget__link" href="/posts/cheatsheets/http-cheatsheet/">Cheatsheet 系列 之 HTTP（一）</a></li>
			<li class="widget__item"><a class="widget__link" href="/posts/flutter/flutter-starter/">Flutter 防坑日记</a></li>
			<li class="widget__item"><a class="widget__link" href="/posts/others/yi/">☯️ 周易筮算</a></li>
			<li class="widget__item"><a class="widget__link" href="/posts/others/clean-code/">代码看起来越“干净”越好？？？</a></li>
			<li class="widget__item"><a class="widget__link" href="/posts/js/sse-express/">使用 Node.js 实现一个简单的 SSE 服务</a></li>
			<li class="widget__item"><a class="widget__link" href="/posts/js/new-of-es2020/">What&#39;s New in ECMAScript 2020 (ES11)</a></li>
			<li class="widget__item"><a class="widget__link" href="/posts/js/data-bindings-react-vue/">Thoughts of Data Bindings Strategies in React and Vue</a></li>
			<li class="widget__item"><a class="widget__link" href="/posts/js/snippets01/">Useful JavaScript Snippets</a></li>
			<li class="widget__item"><a class="widget__link" href="/posts/linux/manjaro-tricks/">Manjaro 踩坑记</a></li>
		</ul>
	</div>
</div>
<div class="widget-categories widget">
	<h4 class="widget__title">Categories</h4>
	<div class="widget__content">
		<ul class="widget__list">
			<li class="widget__item">
				<a class="widget__link" href="/categories/about/">about</a>
			</li>
			<li class="widget__item">
				<a class="widget__link" href="/categories/blogs/">blogs</a>
			</li>
			<li class="widget__item">
				<a class="widget__link" href="/categories/music/">music</a>
			</li>
			<li class="widget__item">
				<a class="widget__link" href="/categories/notes/">notes</a>
			</li>
			<li class="widget__item">
				<a class="widget__link" href="/categories/quotes/">quotes</a>
			</li>
		</ul>
	</div>
</div>
<div class="widget-taglist widget">
	<h4 class="widget__title">Tags</h4>
	<div class="widget__content">
		<a class="widget-taglist__link widget__link btn" href="/tags/cheatsheet/" title="cheatsheet">cheatsheet (1)</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/flutter/" title="flutter">flutter (1)</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/go/" title="go">go (1)</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/http/" title="http">http (1)</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/javascript/" title="javascript">javascript (7)</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/linux/" title="linux">linux (1)</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/manjaro/" title="manjaro">manjaro (1)</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/music/" title="music">music (3)</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/profile/" title="profile">profile (2)</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/react/" title="react">react (4)</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/ssr/" title="ssr">ssr (1)</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/vue/" title="vue">vue (1)</a>
	</div>
</div>
<div class="widget-social widget">
	<h4 class="widget-social__title widget__title">Social</h4>
	<div class="widget-social__content widget__content">
		<div class="widget-social__item widget__item">
			<a class="widget-social__link widget__link btn" title="GitHub" rel="noopener noreferrer" href="https://github.com/yuqingc" target="_blank">
				<svg class="widget-social__link-icon icon icon-github" width="24" height="24" viewBox="0 0 384 374"><path d="m192 0c-106.1 0-192 85.8-192 191.7 0 84.7 55 156.6 131.3 181.9 9.6 1.8 13.1-4.2 13.1-9.2 0-4.6-.2-16.6-.3-32.6-53.4 11.6-64.7-25.7-64.7-25.7-8.7-22.1-21.3-28-21.3-28-17.4-11.9 1.3-11.6 1.3-11.6 19.3 1.4 29.4 19.8 29.4 19.8 17.1 29.3 44.9 20.8 55.9 15.9 1.7-12.4 6.7-20.8 12.2-25.6-42.6-4.8-87.5-21.3-87.5-94.8 0-20.9 7.5-38 19.8-51.4-2-4.9-8.6-24.3 1.9-50.7 0 0 16.1-5.2 52.8 19.7 15.3-4.2 31.7-6.4 48.1-6.5 16.3.1 32.7 2.2 48.1 6.5 36.7-24.8 52.8-19.7 52.8-19.7 10.5 26.4 3.9 45.9 1.9 50.7 12.3 13.4 19.7 30.5 19.7 51.4 0 73.7-44.9 89.9-87.7 94.6 6.9 5.9 13 17.6 13 35.5 0 25.6-.2 46.3-.2 52.6 0 5.1 3.5 11.1 13.2 9.2 76.2-25.5 131.2-97.3 131.2-182 0-105.9-86-191.7-192-191.7z"/></svg>
				<span>GitHub</span>
			</a>
		</div>
		<div class="widget-social__item widget__item">
			<a class="widget-social__link widget__link btn" title="Email" href="mailto:mr.chenyuqing@live.com">
				<svg class="widget-social__link-icon icon icon-mail" width="24" height="24" viewBox="0 0 416 288"><path d="m0 16v256 16h16 384 16v-16-256-16h-16-384-16zm347 16-139 92.5-139-92.5zm-148 125.5 9 5.5 9-5.5 167-111.5v210h-352v-210z"/></svg>
				<span>mr.chenyuqing@live.com</span>
			</a>
		</div>

		
		<div class="widget-social__item widget__item">
			<a class="widget-social__link widget__link btn" title="(゜-゜)つロ 干杯~" rel="noopener noreferrer" href="https://space.bilibili.com/76849204" target="_blank">
					<svg t="1575645314188" class="widget-social__link-icon  icon" width="24" height="24" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg"><path d="M777.514667 131.669333a53.333333 53.333333 0 0 1 0 75.434667L728.746667 255.829333h49.92A160 160 0 0 1 938.666667 415.872v320a160 160 0 0 1-160 160H245.333333A160 160 0 0 1 85.333333 735.872v-320a160 160 0 0 1 160-160h49.749334L246.4 207.146667a53.333333 53.333333 0 1 1 75.392-75.434667l113.152 113.152c3.370667 3.370667 6.186667 7.04 8.448 10.965333h137.088c2.261333-3.925333 5.12-7.68 8.490667-11.008l113.109333-113.152a53.333333 53.333333 0 0 1 75.434667 0z m1.152 231.253334H245.333333a53.333333 53.333333 0 0 0-53.205333 49.365333l-0.128 4.010667v320c0 28.117333 21.76 51.157333 49.365333 53.162666l3.968 0.170667h533.333334a53.333333 53.333333 0 0 0 53.205333-49.365333l0.128-3.968v-320c0-29.44-23.893333-53.333333-53.333333-53.333334z m-426.666667 106.666666c29.44 0 53.333333 23.893333 53.333333 53.333334v53.333333a53.333333 53.333333 0 1 1-106.666666 0v-53.333333c0-29.44 23.893333-53.333333 53.333333-53.333334z m320 0c29.44 0 53.333333 23.893333 53.333333 53.333334v53.333333a53.333333 53.333333 0 1 1-106.666666 0v-53.333333c0-29.44 23.893333-53.333333 53.333333-53.333334z"></path></svg>
				<span>(゜-゜)つロ 干杯~</span>
			</a>
		</div>
		
	</div>
</div>
</aside>
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2020 yuqingc.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>